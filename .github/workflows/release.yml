# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json

name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Semver version without leading v (example: 1.2.3)"
        required: true
        type: string
      target_ref:
        description: "Git ref to release from (must resolve to main)"
        required: true
        default: "main"
        type: string
      prerelease:
        description: "Mark this release as a prerelease"
        required: true
        default: "false"
        type: choice
        options:
          - "false"
          - "true"

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-production
  # Never cancel in-progress releases to avoid partial tag/commit states.
  cancel-in-progress: false

env:
  RELEASE_VERSION: ${{ inputs.version }}
  RELEASE_TAG: v${{ inputs.version }}

jobs:
  preflight:
    name: release-preflight
    runs-on: ubuntu-latest
    outputs:
      release_date: ${{ steps.meta.outputs.release_date }}
    steps:
      - name: Validate release inputs
        env:
          TARGET_REF: ${{ inputs.target_ref }}
        run: |
          set -euo pipefail

          if [[ ! "${RELEASE_VERSION}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Version must be strict semver (X.Y.Z) without a leading 'v'." >&2
            exit 1
          fi

          if [[ "${TARGET_REF}" != "main" && "${TARGET_REF}" != "refs/heads/main" ]]; then
            echo "Releases are restricted to main. Got target_ref='${TARGET_REF}'." >&2
            exit 1
          fi

      - name: Checkout target ref
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.target_ref }}
          fetch-depth: 0

      - name: Verify ref resolves to origin/main and tag is unused
        run: |
          set -euo pipefail

          target_sha="$(git rev-parse HEAD)"
          main_sha="$(git rev-parse origin/main)"

          if [[ "${target_sha}" != "${main_sha}" ]]; then
            echo "Target ref does not resolve to origin/main." >&2
            echo "target_sha=${target_sha}" >&2
            echo "main_sha=${main_sha}" >&2
            exit 1
          fi

          if git ls-remote --exit-code --tags origin "refs/tags/${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Tag already exists on origin: ${RELEASE_TAG}" >&2
            exit 1
          fi

      - name: Capture release metadata
        id: meta
        run: |
          set -euo pipefail
          echo "release_date=$(date -u +%Y-%m-%d)" >> "${GITHUB_OUTPUT}"

  build-root:
    name: build-root-artifacts
    runs-on: ubuntu-latest
    needs: [preflight]
    steps:
      - name: Checkout target ref
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.target_ref }}

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          # Disable Determinate Systems enterprise features for OSS project
          determinate: false
          extra-conf: |
            experimental-features = nix-command flakes
            require-sigs = false
            extra-substituters = https://nix-r2-cloudflare-flake.cachix.org https://wrangler.cachix.org
            extra-trusted-public-keys = nix-r2-cloudflare-flake.cachix.org-1:pmYucG85iBm6Y+8TxNwqU5j/lmY1UBReZxIXslMFntw= wrangler.cachix.org-1:N/FIcG2qBQcolSpklb2IMDbsfjZKWg+ctxx0mSMXdSs=

      - name: Configure Cachix
        uses: cachix/cachix-action@v16
        with:
          name: nix-r2-cloudflare-flake
          extraPullNames: wrangler
          authToken: ${{ secrets.CACHIX_AUTH_TOKEN }}
          skipPush: true

      - name: Build root CLI package
        run: |
          set -euo pipefail
          nix --accept-flake-config build .#r2

      - name: Package root release artifacts
        run: |
          set -euo pipefail

          mkdir -p artifacts/root artifacts/runtime
          out_path="$(nix --accept-flake-config path-info .#r2)"
          system="$(nix --accept-flake-config eval --raw .#r2.system)"

          if [[ ! -d "${out_path}" ]]; then
            echo "Expected Nix output path does not exist: ${out_path}" >&2
            exit 1
          fi

          nix --accept-flake-config path-info .#r2 > artifacts/root/path-info.txt
          nix --accept-flake-config path-info -S .#r2 > artifacts/root/path-info-size.txt
          echo "${system}" > artifacts/root/system.txt
          nix-store --query --requisites "${out_path}" > artifacts/root/closure-paths.txt
          mapfile -t closure_paths < artifacts/root/closure-paths.txt
          if [[ ${#closure_paths[@]} -eq 0 ]]; then
            echo "Expected non-empty closure path list for ${out_path}." >&2
            exit 1
          fi
          nix-store --export "${closure_paths[@]}" > artifacts/runtime/closure.nar

          tar -czf "artifacts/root/r2-${RELEASE_TAG}-${system}.tar.gz" -C "${out_path}" .

      - name: Upload root release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: root-release-artifacts
          path: artifacts/root/*
          if-no-files-found: error

      - name: Upload root closure runtime artifact
        uses: actions/upload-artifact@v4
        with:
          name: root-closure-runtime
          path: artifacts/runtime/closure.nar
          if-no-files-found: error

  build-worker:
    name: build-worker-artifacts
    runs-on: ubuntu-latest
    needs: [preflight]
    steps:
      - name: Checkout target ref
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.target_ref }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 20
          cache: pnpm
          cache-dependency-path: r2-explorer/pnpm-lock.yaml

      - name: Install dependencies
        working-directory: r2-explorer
        run: pnpm install --frozen-lockfile

      - name: Typecheck
        working-directory: r2-explorer
        run: pnpm run check

      - name: Test
        working-directory: r2-explorer
        run: |
          set -euo pipefail
          mkdir -p test-results
          pnpm test 2>&1 | tee test-results/vitest.log

      - name: Upload test results
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: r2-explorer/test-results/
          if-no-files-found: ignore

      - name: Package worker release artifacts
        run: |
          set -euo pipefail

          mkdir -p artifacts/worker

          node --version > artifacts/worker/node-version.txt
          pnpm --version > artifacts/worker/pnpm-version.txt
          (
            cd r2-explorer
            pnpm exec wrangler --version
          ) > artifacts/worker/wrangler-version.txt

          tar -czf "artifacts/worker/r2-explorer-${RELEASE_TAG}.tar.gz" \
            r2-explorer/src \
            r2-explorer/package.json \
            r2-explorer/pnpm-lock.yaml \
            r2-explorer/tsconfig.json \
            r2-explorer/vitest.config.ts \
            r2-explorer/wrangler.toml

      - name: Upload worker release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: worker-release-artifacts
          path: artifacts/worker/*
          if-no-files-found: error

  verify-cli-smoke:
    name: verify-cli-smoke
    runs-on: ubuntu-latest
    needs: [preflight, build-root]
    steps:
      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main
        with:
          determinate: false
          extra-conf: |
            experimental-features = nix-command flakes
            require-sigs = false
            extra-substituters = https://nix-r2-cloudflare-flake.cachix.org https://wrangler.cachix.org
            extra-trusted-public-keys = nix-r2-cloudflare-flake.cachix.org-1:pmYucG85iBm6Y+8TxNwqU5j/lmY1UBReZxIXslMFntw= wrangler.cachix.org-1:N/FIcG2qBQcolSpklb2IMDbsfjZKWg+ctxx0mSMXdSs=

      - name: Download root artifacts
        uses: actions/download-artifact@v4
        with:
          name: root-release-artifacts
          path: release-artifacts/root

      - name: Download root closure runtime artifact
        uses: actions/download-artifact@v4
        with:
          name: root-closure-runtime
          path: release-artifacts/runtime

      - name: Run CLI smoke checks from packaged artifact
        run: |
          set -euo pipefail

          mapfile -t tarballs < <(
            find release-artifacts/root \
              -maxdepth 1 \
              -type f \
              -name "r2-${RELEASE_TAG}-*.tar.gz" \
              -print
          )

          if [[ ${#tarballs[@]} -ne 1 ]]; then
            echo "Expected exactly one root CLI artifact tarball for ${RELEASE_TAG}, found ${#tarballs[@]}." >&2
            exit 1
          fi

          if [[ ! -f release-artifacts/runtime/closure.nar ]]; then
            echo "Missing closure export: release-artifacts/runtime/closure.nar" >&2
            exit 1
          fi

          nix-store --import < release-artifacts/runtime/closure.nar >/dev/null

          extract_dir="$(mktemp -d "${RUNNER_TEMP}/r2-cli-smoke.XXXXXX")"
          trap 'rm -rf "${extract_dir}"' EXIT

          tar -xzf "${tarballs[0]}" -C "${extract_dir}"
          r2_bin="${extract_dir}/bin/r2"

          if [[ ! -x "${r2_bin}" ]]; then
            echo "Extracted r2 binary is missing or not executable: ${r2_bin}" >&2
            exit 1
          fi

          "${r2_bin}" help
          "${r2_bin}" bucket help
          "${r2_bin}" share help
          "${r2_bin}" share worker help

  publish-release:
    name: publish-release
    runs-on: ubuntu-latest
    needs: [preflight, build-root, build-worker, verify-cli-smoke]
    steps:
      - name: Checkout target ref
        uses: actions/checkout@v6
        with:
          ref: ${{ inputs.target_ref }}
          fetch-depth: 0

      - name: Download root artifacts
        uses: actions/download-artifact@v4
        with:
          name: root-release-artifacts
          path: release-artifacts/root

      - name: Download worker artifacts
        uses: actions/download-artifact@v4
        with:
          name: worker-release-artifacts
          path: release-artifacts/worker

      - name: Prepare changelog and release notes
        env:
          RELEASE_DATE: ${{ needs.preflight.outputs.release_date }}
        run: |
          set -euo pipefail

          ./scripts/release/prepare-changelog.sh \
            --version "${RELEASE_VERSION}" \
            --date "${RELEASE_DATE}"

          ./scripts/release/generate-release-notes.sh \
            --version "${RELEASE_VERSION}" \
            > RELEASE_NOTES.md

      - name: Commit changelog for release PR
        run: |
          set -euo pipefail

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add CHANGELOG.md
          if git diff --cached --quiet; then
            echo "No changelog changes were produced for ${RELEASE_TAG}." >&2
            exit 1
          fi

          git commit -m "chore(release): ${RELEASE_TAG}"

      - name: Push release branch and open release PR
        id: release_pr
        env:
          RELEASE_PUSH_TOKEN: ${{ secrets.RELEASE_PUSH_TOKEN }}
        run: |
          set -euo pipefail

          auth_token="${RELEASE_PUSH_TOKEN}"
          if [[ -z "${auth_token}" ]]; then
            auth_token="${{ github.token }}"
          fi
          echo "::add-mask::${auth_token}"
          export GH_TOKEN="${auth_token}"

          release_branch="release/${RELEASE_TAG}"
          pr_title="chore(release): ${RELEASE_TAG}"

          git branch -f "${release_branch}" HEAD
          git remote set-url origin "https://x-access-token:${auth_token}@github.com/${GITHUB_REPOSITORY}.git"
          git push --force-with-lease origin "${release_branch}"

          existing_pr_json="$(gh pr list \
            --repo "${GITHUB_REPOSITORY}" \
            --head "${release_branch}" \
            --base "main" \
            --state "open" \
            --json number,url \
            --jq 'if length > 0 then .[0] else {} end')"

          pr_number="$(jq -r '.number // empty' <<< "${existing_pr_json}")"
          pr_url="$(jq -r '.url // empty' <<< "${existing_pr_json}")"

          if [[ -z "${pr_number}" ]]; then
            body_file="$(mktemp)"
            printf '%s\n\n%s\n%s\n' \
              "Release automation created this PR for \`${RELEASE_TAG}\`." \
              "After required checks pass, this PR is auto-merged by the release workflow." \
              "Tagging and GitHub Release publication happen only after merge to \`main\`." \
              > "${body_file}"
            pr_url="$(gh pr create \
              --repo "${GITHUB_REPOSITORY}" \
              --base "main" \
              --head "${release_branch}" \
              --title "${pr_title}" \
              --body-file "${body_file}")"
            rm -f "${body_file}"
            pr_number="${pr_url##*/}"
          fi

          {
            echo "release_branch=${release_branch}"
            echo "pr_number=${pr_number}"
            echo "pr_url=${pr_url}"
          } >> "${GITHUB_OUTPUT}"

      - name: Enable auto-merge for release PR
        env:
          RELEASE_PUSH_TOKEN: ${{ secrets.RELEASE_PUSH_TOKEN }}
        run: |
          set -euo pipefail

          auth_token="${RELEASE_PUSH_TOKEN}"
          if [[ -z "${auth_token}" ]]; then
            auth_token="${{ github.token }}"
          fi
          echo "::add-mask::${auth_token}"
          export GH_TOKEN="${auth_token}"

          pr_number="${{ steps.release_pr.outputs.pr_number }}"
          if ! gh pr merge "${pr_number}" --repo "${GITHUB_REPOSITORY}" --merge --auto; then
            auto_merge_enabled="$(gh pr view "${pr_number}" --repo "${GITHUB_REPOSITORY}" --json autoMergeRequest --jq 'if .autoMergeRequest == null then "false" else "true" end')"
            if [[ "${auto_merge_enabled}" != "true" ]]; then
              echo "Failed to enable auto-merge for PR #${pr_number}." >&2
              exit 1
            fi
          fi

      - name: Wait for release PR merge
        env:
          RELEASE_PUSH_TOKEN: ${{ secrets.RELEASE_PUSH_TOKEN }}
        run: |
          set -euo pipefail

          auth_token="${RELEASE_PUSH_TOKEN}"
          if [[ -z "${auth_token}" ]]; then
            auth_token="${{ github.token }}"
          fi
          echo "::add-mask::${auth_token}"
          export GH_TOKEN="${auth_token}"

          pr_number="${{ steps.release_pr.outputs.pr_number }}"
          timeout_seconds=5400
          poll_interval_seconds=20
          deadline="$(( $(date +%s) + timeout_seconds ))"

          while true; do
            pr_json="$(gh pr view "${pr_number}" --repo "${GITHUB_REPOSITORY}" --json state,mergedAt,mergeStateStatus,url,autoMergeRequest)"
            pr_state="$(jq -r '.state' <<< "${pr_json}")"
            merged_at="$(jq -r '.mergedAt // ""' <<< "${pr_json}")"
            merge_state_status="$(jq -r '.mergeStateStatus // ""' <<< "${pr_json}")"
            auto_merge_enabled="$(jq -r 'if .autoMergeRequest == null then "false" else "true" end' <<< "${pr_json}")"

            echo "PR #${pr_number} state=${pr_state} mergeStateStatus=${merge_state_status} autoMerge=${auto_merge_enabled} mergedAt=${merged_at}"

            if [[ "${pr_state}" == "MERGED" ]]; then
              break
            fi

            if [[ "${pr_state}" == "CLOSED" ]]; then
              echo "Release PR #${pr_number} was closed without merge." >&2
              exit 1
            fi

            if [[ "${auto_merge_enabled}" != "true" ]]; then
              echo "Auto-merge is not enabled for release PR #${pr_number}." >&2
              exit 1
            fi

            if (( $(date +%s) >= deadline )); then
              echo "Timed out waiting for release PR #${pr_number} to merge." >&2
              exit 1
            fi

            sleep "${poll_interval_seconds}"
          done

      - name: Create and push release tag
        env:
          RELEASE_PUSH_TOKEN: ${{ secrets.RELEASE_PUSH_TOKEN }}
        run: |
          set -euo pipefail

          push_token="${RELEASE_PUSH_TOKEN}"
          if [[ -z "${push_token}" ]]; then
            push_token="${{ github.token }}"
          fi
          echo "::add-mask::${push_token}"

          git remote set-url origin "https://x-access-token:${push_token}@github.com/${GITHUB_REPOSITORY}.git"
          git fetch origin main --tags

          if git ls-remote --exit-code --tags origin "refs/tags/${RELEASE_TAG}" >/dev/null 2>&1; then
            echo "Tag already exists on origin: ${RELEASE_TAG}" >&2
            exit 1
          fi

          if ! git show "origin/main:CHANGELOG.md" | grep -Eq "^## \\[${RELEASE_TAG}\\] - "; then
            echo "Expected ${RELEASE_TAG} heading not found in origin/main CHANGELOG.md after merge." >&2
            exit 1
          fi

          main_sha="$(git rev-parse origin/main)"
          git tag -a "${RELEASE_TAG}" "${main_sha}" -m "Release ${RELEASE_TAG}"
          git push origin "refs/tags/${RELEASE_TAG}"

      - name: Create GitHub release
        env:
          RELEASE_PUSH_TOKEN: ${{ secrets.RELEASE_PUSH_TOKEN }}
        run: |
          set -euo pipefail

          gh_token="${RELEASE_PUSH_TOKEN}"
          if [[ -z "${gh_token}" ]]; then
            gh_token="${{ github.token }}"
          fi
          echo "::add-mask::${gh_token}"
          export GH_TOKEN="${gh_token}"

          release_args=(
            "${RELEASE_TAG}"
            "--title"
            "${RELEASE_TAG}"
            "--notes-file"
            "RELEASE_NOTES.md"
          )

          if [[ "${{ inputs.prerelease }}" == "true" ]]; then
            release_args+=("--prerelease")
          fi

          shopt -s nullglob
          assets=(release-artifacts/root/* release-artifacts/worker/*)
          shopt -u nullglob
          if [[ ${#assets[@]} -eq 0 ]]; then
            echo "No release assets found under release-artifacts/." >&2
            exit 1
          fi
          release_args+=("${assets[@]}")

          gh release create "${release_args[@]}"
